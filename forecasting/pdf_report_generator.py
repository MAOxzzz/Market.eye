import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import os
import base64
from datetime import datetime
from io import BytesIO
from fpdf import FPDF
import PIL
from PIL import Image

class PDFReportGenerator:
    """
    A dedicated PDF report generation module for Market Eye AI.
    This class handles the creation of comprehensive, formatted stock analysis reports
    including analytical tables, figures, forecast comparisons, error metrics, and LLM-generated text.
    """
    
    def __init__(self, output_dir="reports"):
        """
        Initialize the PDF report generator.
        
        Args:
            output_dir (str): Directory to save the generated reports
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Set matplotlib to use Agg backend to work in environments without display
        matplotlib.use('Agg')
    
    def create_analytical_report(self, user, ticker, analytics_data=None, forecast_data=None, 
                                 historical_data=None, recommendation=None, error_metrics=None,
                                 llm_insights=None):
        """
        Create a comprehensive analytical report with all available data.
        
        Args:
            user (str): Username for whom the report is generated
            ticker (str): Stock ticker symbol
            analytics_data (dict): Analytics data including company comparisons
            forecast_data (dict): Forecast data including predicted values
            historical_data (pd.DataFrame): Historical price data
            recommendation (str): AI-generated recommendation text
            error_metrics (dict): Model error metrics (MSE, RMSE, etc.)
            llm_insights (str): Additional insights generated by LLM
            
        Returns:
            str: Path to the generated PDF report
        """
        # Create PDF document
        pdf = FPDF()
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        
        # Add header
        self._add_header(pdf, user, ticker)
        
        # Add recommendation if available
        if recommendation:
            self._add_recommendation_section(pdf, recommendation)
        
        # Add analytics data if available
        if analytics_data:
            self._add_analytics_section(pdf, analytics_data)
        
        # Add comparison chart if both historical and forecast data available
        if historical_data is not None and forecast_data is not None:
            self._add_comparison_chart(pdf, historical_data, forecast_data, ticker)
        
        # Add forecast data if available
        if forecast_data:
            self._add_forecast_section(pdf, forecast_data)
        
        # Add error metrics if available
        if error_metrics:
            self._add_error_metrics_section(pdf, error_metrics)
        
        # Add LLM insights if available
        if llm_insights:
            self._add_llm_insights_section(pdf, llm_insights)
        
        # Generate filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"{ticker}_analysis_{timestamp}.pdf"
        filepath = os.path.join(self.output_dir, filename)
        
        # Save PDF
        pdf.output(filepath)
        
        return filepath
    
    def _add_header(self, pdf, user, ticker):
        """Add header to the PDF report."""
        pdf.set_font("Arial", 'B', size=16)
        pdf.cell(0, 10, txt=f"Market Eye AI - Stock Analysis Report", ln=True, align='C')
        pdf.set_font("Arial", size=12)
        pdf.cell(0, 10, txt=f"Ticker: {ticker}", ln=True, align='C')
        pdf.cell(0, 10, txt=f"Generated for: {user}", ln=True, align='C')
        pdf.cell(0, 10, txt=f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=True, align='C')
        pdf.ln(5)
    
    def _add_recommendation_section(self, pdf, recommendation):
        """Add AI recommendation section to the PDF."""
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt="AI Investment Recommendation", ln=True)
        pdf.set_font("Arial", size=10)
        pdf.multi_cell(0, 5, txt=recommendation)
        pdf.ln(5)
    
    def _add_analytics_section(self, pdf, analytics_data):
        """Add analytics data section to the PDF."""
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt="Stock Analytics", ln=True)
        
        # Add company comparison if available
        if 'company_comparison' in analytics_data:
            self._add_company_comparison_table(pdf, analytics_data['company_comparison'])
        
        # Add sector comparison if available
        if 'sector_comparison' in analytics_data:
            self._add_sector_comparison_table(pdf, analytics_data['sector_comparison'])
            
        pdf.ln(5)
    
    def _add_company_comparison_table(self, pdf, company_comparison):
        """Add company comparison table to the PDF."""
        pdf.set_font("Arial", 'B', size=12)
        pdf.cell(0, 10, txt="Company Comparison", ln=True)
        pdf.set_font("Arial", size=8)
        
        # Calculate column widths based on content
        col_widths = [25, 30, 30, 35, 30, 30]
        
        # Table headers
        headers = ["Ticker", "Highest Price", "Lowest Price", "Annual Growth %", "Volatility %", "Current Price"]
        
        # Set fill color for header
        pdf.set_fill_color(200, 220, 255)
        
        # Create header row
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 10, txt=header, border=1, fill=True)
        pdf.ln()
        
        # If company_comparison is a DataFrame, iterate through rows
        if isinstance(company_comparison, pd.DataFrame):
            for _, row in company_comparison.iterrows():
                pdf.cell(col_widths[0], 10, txt=str(row.get('ticker', 'N/A')), border=1)
                pdf.cell(col_widths[1], 10, txt=f"${row.get('highest_price', 0):.2f}", border=1)
                pdf.cell(col_widths[2], 10, txt=f"${row.get('lowest_price', 0):.2f}", border=1)
                pdf.cell(col_widths[3], 10, txt=f"{row.get('annual_growth', 0):.2f}%", border=1)
                pdf.cell(col_widths[4], 10, txt=f"{row.get('volatility', 0):.2f}%", border=1)
                pdf.cell(col_widths[5], 10, txt=f"${row.get('current_price', 0):.2f}", border=1)
                pdf.ln()
        # If it's a dictionary, format accordingly
        elif isinstance(company_comparison, dict):
            for ticker, data in company_comparison.items():
                pdf.cell(col_widths[0], 10, txt=ticker, border=1)
                pdf.cell(col_widths[1], 10, txt=f"${data.get('highest_price', 0):.2f}", border=1)
                pdf.cell(col_widths[2], 10, txt=f"${data.get('lowest_price', 0):.2f}", border=1)
                pdf.cell(col_widths[3], 10, txt=f"{data.get('annual_growth', 0):.2f}%", border=1)
                pdf.cell(col_widths[4], 10, txt=f"{data.get('volatility', 0):.2f}%", border=1)
                pdf.cell(col_widths[5], 10, txt=f"${data.get('current_price', 0):.2f}", border=1)
                pdf.ln()
    
    def _add_sector_comparison_table(self, pdf, sector_comparison):
        """Add sector comparison table to the PDF."""
        pdf.set_font("Arial", 'B', size=12)
        pdf.cell(0, 10, txt="Sector Comparison", ln=True)
        pdf.set_font("Arial", size=8)
        
        # Calculate column widths based on content
        col_widths = [35, 35, 35, 35, 35]
        
        # Table headers
        headers = ["Sector", "Avg Growth %", "Avg Volatility %", "Market Cap", "# Companies"]
        
        # Set fill color for header
        pdf.set_fill_color(200, 220, 255)
        
        # Create header row
        for i, header in enumerate(headers):
            pdf.cell(col_widths[i], 10, txt=header, border=1, fill=True)
        pdf.ln()
        
        # If sector_comparison is a DataFrame, iterate through rows
        if isinstance(sector_comparison, pd.DataFrame):
            for sector, row in sector_comparison.iterrows():
                pdf.cell(col_widths[0], 10, txt=sector, border=1)
                pdf.cell(col_widths[1], 10, txt=f"{row.get('avg_annual_growth', 0):.2f}%", border=1)
                pdf.cell(col_widths[2], 10, txt=f"{row.get('avg_volatility', 0):.2f}%", border=1)
                pdf.cell(col_widths[3], 10, txt=f"${row.get('total_market_cap', 0):.2f}B", border=1)
                pdf.cell(col_widths[4], 10, txt=str(row.get('num_companies', 0)), border=1)
                pdf.ln()
    
    def _add_comparison_chart(self, pdf, historical_data, forecast_data, ticker):
        """
        Add a comparison chart of historical vs. forecast data.
        
        Args:
            pdf (FPDF): PDF document
            historical_data (pd.DataFrame): Historical price data
            forecast_data (dict): Forecast data including predicted values
            ticker (str): Stock ticker symbol
        """
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt="Historical vs. Forecast Comparison", ln=True)
        
        try:
            # Create the comparison chart
            plt.figure(figsize=(10, 6))
            
            # Plot historical data
            if 'Date' in historical_data.columns and 'Close' in historical_data.columns:
                plt.plot(historical_data['Date'], historical_data['Close'], 
                         label='Historical Prices', color='blue')
            
            # Plot forecast data
            if 'forecast_df' in forecast_data:
                forecast_df = forecast_data['forecast_df']
                if 'Date' in forecast_df.columns and 'Predicted_Close' in forecast_df.columns:
                    plt.plot(forecast_df['Date'], forecast_df['Predicted_Close'], 
                             label='Forecast Prices', color='red', linestyle='--')
            
            plt.title(f"{ticker} - Historical vs. Forecast Prices")
            plt.xlabel("Date")
            plt.ylabel("Price ($)")
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            # Save the figure to a temporary buffer
            buf = BytesIO()
            plt.savefig(buf, format='png', dpi=300, bbox_inches='tight')
            plt.close()
            buf.seek(0)
            
            # Add the image to the PDF
            img_path = os.path.join(self.output_dir, f'temp_comparison_{ticker}.png')
            with open(img_path, 'wb') as f:
                f.write(buf.getvalue())
            
            # Add the image to PDF with proper scaling
            pdf.image(img_path, x=10, y=pdf.get_y(), w=190)
            pdf.ln(130)  # Add space for the image
            
            # Remove temporary file
            os.remove(img_path)
            
        except Exception as e:
            pdf.set_text_color(255, 0, 0)
            pdf.multi_cell(0, 5, txt=f"Error generating comparison chart: {str(e)}")
            pdf.set_text_color(0, 0, 0)
            pdf.ln(5)
    
    def _add_forecast_section(self, pdf, forecast_data):
        """Add forecast data section to the PDF."""
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt=f"Stock Price Forecast", ln=True)
        
        # Add forecast table
        if 'forecast_df' in forecast_data:
            self._add_forecast_table(pdf, forecast_data['forecast_df'])
        
        pdf.ln(5)
    
    def _add_forecast_table(self, pdf, forecast_df):
        """Add forecast table to the PDF."""
        pdf.set_font("Arial", 'B', size=12)
        pdf.cell(0, 10, txt="Price Forecast", ln=True)
        pdf.set_font("Arial", size=9)
        
        # Calculate column widths
        col_widths = [60, 60]
        
        # Table headers
        pdf.set_fill_color(200, 220, 255)
        pdf.cell(col_widths[0], 10, txt="Date", border=1, fill=True)
        pdf.cell(col_widths[1], 10, txt="Predicted Price", border=1, fill=True)
        pdf.ln()
        
        # If forecast_df is a DataFrame, iterate through rows
        if isinstance(forecast_df, pd.DataFrame):
            # Show only a subset of rows if there are too many
            rows_to_show = min(15, len(forecast_df))
            step = max(1, len(forecast_df) // rows_to_show)
            
            for i in range(0, len(forecast_df), step):
                if i < rows_to_show:
                    row = forecast_df.iloc[i]
                    date_str = row['Date'].strftime('%Y-%m-%d') if isinstance(row['Date'], (datetime, pd.Timestamp)) else str(row['Date'])
                    price_col = 'Predicted_Close' if 'Predicted_Close' in row else 'Close'
                    pdf.cell(col_widths[0], 10, txt=date_str, border=1)
                    pdf.cell(col_widths[1], 10, txt=f"${row[price_col]:.2f}", border=1)
                    pdf.ln()
    
    def _add_error_metrics_section(self, pdf, error_metrics):
        """Add error metrics section to the PDF."""
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt="Forecast Error Metrics", ln=True)
        pdf.set_font("Arial", size=10)
        
        # Create table for error metrics
        pdf.set_fill_color(200, 220, 255)
        
        # Calculate column widths
        col_width = 45
        
        # Header row
        metrics_to_display = ['MSE', 'RMSE', 'MAE', 'RÂ²', 'Accuracy']
        for metric in metrics_to_display:
            pdf.cell(col_width, 10, txt=metric, border=1, fill=True)
        pdf.ln()
        
        # Values row
        pdf.cell(col_width, 10, txt=f"{error_metrics.get('mse', 'N/A'):.4f}", border=1)
        pdf.cell(col_width, 10, txt=f"{error_metrics.get('rmse', 'N/A'):.4f}", border=1)
        pdf.cell(col_width, 10, txt=f"{error_metrics.get('mae', 'N/A'):.4f}", border=1)
        pdf.cell(col_width, 10, txt=f"{error_metrics.get('r2', 'N/A'):.4f}", border=1)
        pdf.cell(col_width, 10, txt=f"{error_metrics.get('accuracy_5pct', 'N/A'):.2f}%", border=1)
        pdf.ln(15)
        
        # Add error metrics visualization if available
        if 'visualization' in error_metrics:
            try:
                # If visualization is a file path
                if isinstance(error_metrics['visualization'], str) and os.path.exists(error_metrics['visualization']):
                    pdf.image(error_metrics['visualization'], x=10, y=pdf.get_y(), w=190)
                    pdf.ln(130)  # Add space for the image
            except Exception as e:
                pdf.set_text_color(255, 0, 0)
                pdf.multi_cell(0, 5, txt=f"Error adding visualization: {str(e)}")
                pdf.set_text_color(0, 0, 0)
    
    def _add_llm_insights_section(self, pdf, llm_insights):
        """Add LLM-generated insights section to the PDF."""
        pdf.set_font("Arial", 'B', size=14)
        pdf.cell(0, 10, txt="AI-Generated Market Insights", ln=True)
        pdf.set_font("Arial", size=10)
        
        # If llm_insights is a string
        if isinstance(llm_insights, str):
            pdf.multi_cell(0, 5, txt=llm_insights)
        
        # If llm_insights is a dictionary with structured insights
        elif isinstance(llm_insights, dict):
            # Add summary if available
            if 'summary' in llm_insights:
                pdf.set_font("Arial", 'B', size=12)
                pdf.cell(0, 10, txt="Summary", ln=True)
                pdf.set_font("Arial", size=10)
                pdf.multi_cell(0, 5, txt=llm_insights['summary'])
                pdf.ln(5)
            
            # Add recommendations if available
            if 'recommendations' in llm_insights:
                pdf.set_font("Arial", 'B', size=12)
                pdf.cell(0, 10, txt="Recommendations", ln=True)
                pdf.set_font("Arial", size=10)
                pdf.multi_cell(0, 5, txt=llm_insights['recommendations'])
                pdf.ln(5)
            
            # Add risk assessment if available
            if 'risk_assessment' in llm_insights:
                pdf.set_font("Arial", 'B', size=12)
                pdf.cell(0, 10, txt="Risk Assessment", ln=True)
                pdf.set_font("Arial", size=10)
                pdf.multi_cell(0, 5, txt=llm_insights['risk_assessment'])
                pdf.ln(5)
    
    def get_download_link(self, filepath):
        """
        Generate a download link for the report.
        
        Args:
            filepath (str): Path to the generated PDF report
            
        Returns:
            str: HTML link for downloading the report
        """
        with open(filepath, "rb") as f:
            pdf_data = f.read()
        
        b64 = base64.b64encode(pdf_data).decode()
        filename = os.path.basename(filepath)
        
        return f'<a href="data:application/pdf;base64,{b64}" download="{filename}">Download {filename}</a>'


def generate_error_metrics_chart(actual, predicted, title="Forecast Error Analysis"):
    """
    Generate a visualization of error metrics.
    
    Args:
        actual (array-like): Actual values
        predicted (array-like): Predicted values
        title (str): Chart title
        
    Returns:
        BytesIO: Buffer containing the chart image
    """
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    
    # Plot 1: Actual vs Predicted
    ax1.scatter(actual, predicted, alpha=0.5)
    ax1.plot([min(actual), max(actual)], [min(actual), max(actual)], 'r--')
    ax1.set_xlabel('Actual Values')
    ax1.set_ylabel('Predicted Values')
    ax1.set_title('Actual vs Predicted')
    ax1.grid(True, alpha=0.3)
    
    # Plot 2: Error Distribution
    errors = np.array(predicted) - np.array(actual)
    ax2.hist(errors, bins=20, alpha=0.7)
    ax2.axvline(x=0, color='r', linestyle='--')
    ax2.set_xlabel('Prediction Error')
    ax2.set_ylabel('Frequency')
    ax2.set_title('Error Distribution')
    ax2.grid(True, alpha=0.3)
    
    plt.suptitle(title)
    plt.tight_layout()
    
    # Save the figure to a buffer
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=300, bbox_inches='tight')
    plt.close(fig)
    buf.seek(0)
    
    return buf


# Example usage:
if __name__ == "__main__":
    # Create a sample report
    report_generator = PDFReportGenerator()
    
    # Sample data
    analytics_data = {
        'company_comparison': pd.DataFrame({
            'ticker': ['AAPL', 'MSFT', 'GOOGL'],
            'highest_price': [200.0, 180.0, 150.0],
            'lowest_price': [150.0, 120.0, 100.0],
            'annual_growth': [15.2, 12.5, 10.8],
            'volatility': [20.5, 18.2, 22.1],
            'current_price': [180.5, 170.2, 140.3]
        })
    }
    
    historical_data = pd.DataFrame({
        'Date': pd.date_range(start='2023-01-01', periods=30),
        'Close': np.random.normal(100, 5, 30)
    })
    
    forecast_data = {
        'ticker': 'AAPL',
        'forecast_df': pd.DataFrame({
            'Date': pd.date_range(start='2023-02-01', periods=10),
            'Predicted_Close': np.random.normal(105, 8, 10)
        }),
        'metrics': {
            'rmse': 2.45,
            'mse': 6.00,
            'mae': 1.95,
            'r2': 0.85,
            'accuracy_5pct': 85.0
        }
    }
    
    # Generate error metrics visualization
    actual = historical_data['Close'].values[-10:]
    predicted = forecast_data['forecast_df']['Predicted_Close'].values[:10]
    error_viz_buffer = generate_error_metrics_chart(actual, predicted)
    
    # Save visualization to a temporary file
    temp_viz_path = os.path.join(report_generator.output_dir, 'temp_error_viz.png')
    with open(temp_viz_path, 'wb') as f:
        f.write(error_viz_buffer.getvalue())
    
    error_metrics = {
        'mse': 6.00,
        'rmse': 2.45,
        'mae': 1.95,
        'r2': 0.85,
        'accuracy_5pct': 85.0,
        'visualization': temp_viz_path
    }
    
    llm_insights = {
        'summary': "Apple Inc. has shown strong performance over the past quarter with a 15% increase in stock price.",
        'recommendations': "BUY - The company's robust product pipeline and services growth suggest continued upward momentum.",
        'risk_assessment': "Low to moderate risk. Supply chain constraints remain a concern, but Apple's cash reserves provide a strong buffer."
    }
    
    # Generate a sample report
    report_path = report_generator.create_analytical_report(
        user="test_user",
        ticker="AAPL",
        analytics_data=analytics_data,
        forecast_data=forecast_data,
        historical_data=historical_data,
        recommendation="BUY - Apple Inc. shows strong growth potential based on recent performance and upcoming product releases.",
        error_metrics=error_metrics,
        llm_insights=llm_insights
    )
    
    print(f"Report generated: {report_path}")
    
    # Clean up temporary visualization file
    if os.path.exists(temp_viz_path):
        os.remove(temp_viz_path) 